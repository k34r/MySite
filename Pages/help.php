<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Help</title>
    <link type='text/css' rel="stylesheet" href="CSS/css/bootstrap.min.css">
	<style type="text/css">
    #text_pole { margin: 70px;}
        h1,h2{text-align: center;color: #338}
        span{color: #0b0;}
        }
	</style>
</head>
<body>

<?php require_once 'PageComponents/header.html'; ?>
<div id="text_pole">
<h1>Что такое rewriterule</h1>
<p>В сегодняшней статье рассмотрим работу модуля <i>mod_rewrite</i> сервера Apache, и как с помощью правил RewriteRule и RewriteCond работать с URL. Поговорим про описание и логику работы правила RewriteRule, а так же синтаксис некоторых директив модуля mod_rewrite.
	<h2>Немного теории</h2>
	<p>Веб-сайты работают благодаря серверам - компьютерам с установленным программным обеспечением, отвечающим за передачу информации от физических хранилищ до браузера пользователя.<br><br>

		Apache - это программное кроссплатформенное обеспечение, основное назначение которого HTTP-сервер.<br><br>

	HTTP сервер или веб-сервер - это программа, которая понимает, что нужно клиенту и выдает ему ответы в виде HTML страниц, на которых может содержаться различная информация: изображения, тексты, скрипты, файлы, медиаданные (видео и аудио) и многое другое. <br><br>
	Apach является самым популярным ПО для веб-серверов в мире, благодаря простоте, гибкости в настройке, надежности, производительности и модульности. <br><br>

	.htaccess - конфигурационный файл Apache, в котором директивами (командами), задаются параметры для работы сервера:
	 <ul>
	 <li>разрешение или запрет доступа к директориям</li>
	 <li>переназначение типов файлов</li>
	 <li>оптимизация скорости загрузки (можно задать кэш для файлов)</li>
	</ul>
	Файл .htaccess располагается в корневой директории сервера и распространяется на весь сервер, кроме директорий, где находится другой файл.</p>
	<p>Чтобы сервер мог работать с директивами, активируйте модуль mod_rewrite в конфигурационном файле (*.conf). Настройка этого модуля, происходит в файле .htaccess. Как это сделать будет описано ниже.<br>
		Команда подключения модулей (LoadModule) прописывается в конфигурационном файле Apache. В зависимости от системы может располагаться:
		<ul><li>Linux, CentOS, Fedora(Redhat-системы) - /etc/httpd/conf/httpd.conf;</li>
	    <li>Apache 2.2 - /etc/apache2/apache2.conf;</li>
	    <li>Gentoo, Apache 2.0 - /etc/apache2/httpd.conf</li></ul></p>
<p>Включить и отключить модуль Apache можно с помощью следующих команд:<br>
	<ul><li>a2enmod</li>
	<li>a2dismod</li></ul>
	Например, подключение модуля rewrite_module происходит с помощью консольной команды:<br><br>

	sudo a2enmod rewrite - <i>включить модуль</i><br><br>

	sudo systemctl restart apache2 - <i>перезагрузить Apache чтобы применилась активация</i><br><br>

	Если используется Apache в Windows, то для включения mod_rewrite в файле httpd.conf <br>
	(C:\Server\bin\Apache24\conf\httpd.conf) найдите и раскомментируйте строку:<br><br>

	<i>LoadModule rewrite_module modules/mod_rewrite.so</i><br><br>
	
	Для этого уберите перед строкой знак "#".<br>
Также используйте знак решетки если не работает что-то из директив. Поставьте ее перед строкой с кодом. Это позволит закомментировать не нужный вам текст, программа при чтении пропустит данную строку.</p>

<h2>Что такое mod_rwrite</h2>

 <p>Это модуль сервера  Apache (программа, работающая на стороне сервера), выполняющий действия с URL, такие как: <ul><li><i>создание редиректов</li><li>ЧПУ</li><li>ограничения доступа к директориям не веб-сайте</i></li></ul>
 	Главная задача - преобразования URL-ов. Например, рассмотрим перенаправление всех страниц домена oldsite.com на соответствующие страницы newsite.com<br></p>
 	<p>RewriteCond %{HTTP_HOST} ^oldsite\.com<br>
 	   RewriteRule ^(.*)$ http: //newsite .com/$1<br>
 	   [R=301,L]<br></p>

<h2>Как работает модуль</h2>

<p>В своей работе mod_rewrite использует регулярные выражения. В них используются
специальные символы (метасимволы) и обычные символы (литералы). Основными метасимволами являются:<br>
[] \ / ^ $ . | ? * + ( ) { } <br>
где наиболее часто используемые спецсимволы:<br>
<ul><li>^ - начало строки</li>
<li>$ - конец строки</li>
<li>. - любой символ</li>
<li>* - любое количество символов</li>
<li>+ - один или более символов</li>
<li>? - один определенный символ</li>
<li>[0-9] - последовательность символов, например от 0 до 9</li>
<li>| - символ "или", выбирается или одна группа, или другая</li>
<li>() - используется для выбора групп символов</li></ul>
<p>Порядок обработки правил (команд) прописывается в .htaccess и составляется примерно в таком порядке:<br>
	<ul><li>&ltIfModule mod_rewrite.c&gt(проверяем что модуль включен)</li>
		<li>RewriteEngine on (один раз сверху)</li>
		<li>RewriteCond %{что сравнивать} с чем сравнивать [флаги]</li>
		<li>RewriteRule исходный url целевой url [флаги]</li>
		<li>&lt/IfModule&gt</li></ul>
Если указано условие RewriteEngine off, то блок IfModule с кодом будет проигнорирован и не выполнится. Где:
<ul><li>RewriteEngine - включает или отключает преобразование http-ссылок</li>
	<li>RewriteCond - условие, которое должно быть соблюдено перед выполнением правила, условий может быть несколько</li>
	<li>RewriteRule - собственно само правило, которое выполняется при соблюдении условия</li></ul>
	<p>Порядок размещения правил в .htaccess важен, потому что механизм преобразований обрабатывает их в специальном порядке. Условия (RewriteCond) всегда должны быть перед правилами (RewriteRule)!</p>

	<h2>Правило преобразования URL RewriteRule</h2>

	Синтаксис директивы RewriteRule:
		<ul><li>RewriteRule <span>Шаблон</span> Подстановка<span> [Флаги]</span></li>
		<li>Пример:</li>
		<li>RewriteRule<span>^(.*)$</span>index.php?/$1<span>[L,QSA]</span></li></ul>

Где RewriteRule это директива;<br>
Шаблон - это символы ^(.*)$. Регулярное выражение применяемое к текущему URL читается так: "искать в строке URL от начала строки (^) до конца ($) любой символ (знак.) в количестве от нуля до бесконечности (знак *)". Например:<br>
<p>^stena - любые строки, начинающиеся со слова stena. Строка, начинающаяся со слова dom-stena не удовлетворит критерию;</p>
<p>stena$ - любые строки, заканчивающиеся набором символов stena. Строка, заканчивающаяся на stena-dom под выбор не попадёт;</p>
<p>[0-9]{1,6}$ - выбрать все строки, оканчивающиеся от 1 до 6 цифрами из диапазона от 0 до 9</p>
<p>В регулярных выражениях есть скобки(). Поэтому часть URL соответствующая условию в скобках добавляется в переменную подстановки $1, которая используется в Подстановке или в Сравниваемая Строка (это в директиве RewriteCond, о ней ниже);</p>
<p>Подстановка - index.php?/$1. Правило преобразования URL. Запись означает, что строка нового, измененного URL должна быть составлени из двух частей, где первая часть строки постоянное значение index.php?/, a вторая часть - значение из переменной подстановки $1. В $1 храниться та часть URL которая соответствовала части регулярного выражения в скобках из параметра Шаблон. Мы получаем преобразованный URL вида index.php?/URL по которому обратились;</p>
[L,QSA] - флаги. Правило означающее, что необходимо остановить процесс преобразования на этом месте и не применять больше никаких следующих правил преобразований для URL. Дополняет преобразование URL третий аргумент директивы RewriteRule.</p>
<p>Рассмотрим флаги RewriteRule подробнее:</p>
<ul><li>[NC] - делает шаблон нечувствительным к регистру, когда он применяется к текущему URL;</li>		
	<li>[QSA] - добавляет строку запроса из исходного URL к строке запроса, созданной правилами перезаписи;</li>
	<li>[L] - останавливает процесс преобразования на этом месте и не применяет больше никаких правил преобразований;</li>
	<li>[N] - перезапускает процесс преобразований (начав с первого правила). В этом случае URL снова сопоставляется неким условиям, но не оригинальный URL, а URL вышедший из последнего правила преобразования;</li>
	<li>[F] - веб сервер возвращает браузеру ошибку с кодом 403; </li>
	<li>[R] - редирект с кодом ответа браузеру 302 (временно перемещен);</li>
	<li>[R=code] - редирект с кодом ответа браузеру code;</li>
	<li>[B] (escape backreferences) - заставляет экранировать (кодировать) спецсимволы, например взять правило "RewriteRule ^search/(.*)$/search.php?term=$1" в котором есть строка поиска, которая может содержать к примеру 'x & y/z' и в результате будет возвращена строка 'search.php?term=x & y/z', что является недопустимым URL и будет преобразовано браузером в 'search.php?term=x%20&y%2Fz='. С флагом [B] строка будет преобразована в '/search.php?term=x%20%26%20y%2Fz'. Для работы этого примера понадобится установить AllowEncodedSlashes в On ибо httpd по умолчанию не позволяет кодировать слэши в URL;</li>
	<li>[C] chain - объединить несколько правил в цепочку. Если первое правило цепочки не удовлетворяет условиям, тогда вся цепочка будет проигнорирована;</li>
	<li>[CO] cookie - устанавливает cookie в формате [CO=NAME:VALUE:DOMAIN:lifetime:path:secure:httponly], параметры для secure и httponly устанавливаются как true|false;</li>
	<li>[DPI] discardpathinfo - отбрасывает PATH_INFO в преобразованной ссылке, полезно использовать в случаях, когда PATH_INFO уже был добавлен в предыдущем преобразовании;
<li>[E] env - установить переменную [E=VAR:VAL] или удалить её [E=!VAR];</li>
<li>[F] forbidden - возвращает ошибку 403;</li>
<li>[G] gone - возвращает ошибку 410;</li>
<li>[H] handler - принудительно устанавливает обработчик для определённых типов файлов, например правило "RewriteRule !\. - [H=application/x-httpd-php]" заставит пропустить через PHP все файлы без расширения;</li>
<li>[L] last - указывает, что правило является последним и процесс дальнейшего преобразования прекращается;</li>
<li>[N] next - начинает процесс преобразования с первого по порядку правила, используйте этот флаг с осторожностью ибо он может привести к замкнутому циклу (т.н. петля);</li>
<li>[NC] nocase - отключает проверку регистра символов;</li>
<li>[NE] noescape - mod_rewrite обычно применяет правила экранирования URI к результату преобразования. Спецсимволы (такие как '%', '$', ';', и так далее) будут экранированы их шестнадцатеричными (hexcode) подстановками ('%25', '%24', и '%3B', соответственно). Этот флаг запрещает делать это;</li>
<li>[NS] nosubreq - игнорировать подзапросы, выполнять правило только для настоящих/прямых запросов;</li>
<li>[P] proxy - Apache выполняет подзапрос к указанной странице с использованием программного модуля mod_proxy, при этом клиент об этом подзапросе ничего не узнает. Произойдет ошибка если модуль mod_proxy не подключен;</li>
<li>[PT] passthrough - остановить преобразование и передать полученную новую ссылку дальше;</li>
<li>[QSA] qsappend - добавляет исходные параметры запроса (query string) к замене. Если в подстановку не включаются новые параметры запроса, то исходные параметры запроса будут добавлены автоматически. Если же новые параметры включаются в подстановку, то исходные параметры запроса будут утеряны если не указать флаг QSA;</li>
<li>[R] redirect - возвращает браузеру команду на перенаправление (по-умолчанию код 302 - MOVED TEMPORARY), код редиректа можно указать самостоятельно, например R=301 (код 301 - MOVED PERMANENTLY), но в границах 300-399, в противном случае правило не будет обработано;</li>
<li>[S] skip - пропускает следующее правило, если данное правило сработало. Можно указать количество правил, например: S=2;</li>
<li>[T] type - принудительно устанавливает MIME-тип целевого файла. К примеру, "RewriteRule \.pl$ - [T=text/plain]", это правило отобразит Perl скрипты в текстовом формате, а значит код скрипта будет выдан в браузер.</li>
</ul>

<h2>RewriteCond примеры</h2>

RewriteCond %{REQUEST_FILENAME} -f  если файл существует, то заходим на него, иначе ошибка 404<br><br>
RewriteCond %{REQUEST_FILENAME} !-f <br>
RewriteRule .+ index.php если файл не существует, то заходим на index.php <br><br>
-f  существующий файл <br>
-s  существующий файл ненулевого размера<br>
-d  существующая папка<br>
REQUEST_FILENAME - полный путь к файлу<br>
REQUEST_URI - адрес в адресной строке<br>

RewriteCond %{REQUEST_FILENAME} -f

<h2>RewriteRule примеры</h2>

Создание понятных для человека URL<br>
ЧПУ — расшифровывается как Человекопонятный URL. Это ссылки которые визуально имеют упрощенную структуру. Ее проще запомнить.<br>
Например, Ссылки вида http://site.com/?page=contacts нужно привести к http://site.com/contacts/.<br>

Все в файле .htaccess пропишите:<br>
<ul>
<li>RewriteRule ^contacts/?$ ?page=contacts </li>
<li>[L,QSA]</li>
<li>RewriteRule ^news/?$ ?page=news [L,QSA]</li>
<li>RewriteRule ^news/([^/]+)/?$ ?</li>
<li>page=news&slug=$1 [L,QSA]</li>
</ul>
<p>Преобразования происходит благодаря флагу QSA (query string append), прописанному в квадратных скобках после каждого правила. Если строка запроса удовлетворяет правилу, она является эквивалентом указанного адреса, и выдает тот же самый контент.<br>
Например, RewriteRule ^news/?$ ?page=news [L,QSA] и обратиться к сайту по адресу /news/, то:</p>

<ol>
<li>Строка запроса /news/ совпадет с указанным в правиле, значит это правило сработает;</li>
<li>Флаг L (last) указывает, что после этого правила другие применяться не будут;</li>
<li>Флаг QSA указывает на подстановку строки запроса и ее НЕ ЧПУ аналог;</li>
<li>Строка запроса /news/ аналогична НЕ ЧПУ адресу ?page=news;</li>
<li>По запросу /news/ выводится контент точно такой же, как и если набрать ?page=news.</li>
</ol>
</div>

</body>
</html>